use std::{
    collections::{HashMap, HashSet},
    fs::File,
    io::{BufRead, BufReader},
};

fn input() -> Vec<u64> {
    let file = File::open("input/22.txt").unwrap();
    let reader = BufReader::new(file);

    reader
        .lines()
        .map(|line| line.unwrap().trim().parse::<u64>().unwrap())
        .collect()
}

#[allow(dead_code)]
pub fn puzzle_1() -> u64 {
    // Get input
    let numbers = input();

    // For each buyer, simulate the creation of 2000 new secret numbers.
    // Compute the sum of the 2000th secret number generated by each buyer
    numbers
        .into_iter()
        .map(|mut n| {
            for _ in 0..2000 {
                n = next(n);
            }
            n
        })
        .sum()
}

fn next(mut n: u64) -> u64 {
    n = (n ^ (n << 6)) & 0xFFFFFF;
    n = (n ^ (n >> 5)) & 0xFFFFFF;
    n = (n ^ (n << 11)) & 0xFFFFFF;
    n
}

#[allow(dead_code)]
pub fn puzzle_2() -> usize {
    // Get input
    let numbers = input();

    // For every starting number, simulate the 2000 newly generated numbers,
    // keep track of each pattern that appears, and what the associated prices will be
    let mut total_price = HashMap::new();
    for n in numbers {
        predict_price(n, &mut total_price);
    }

    // Read off the maximum number of bananas
    let bananas = *total_price.values().max().unwrap() as usize;

    bananas
}

fn predict_price(mut n: u64, total_price: &mut HashMap<(i32, i32, i32, i32), i32>) {
    // Differences in prices
    let mut a;
    let mut b = 0;
    let mut c = 0;
    let mut d = 0;

    // Hashset to keep track of which patterns already appeared
    let mut seen = HashSet::new();

    let mut price = (n % 10) as i32;
    for k in 0..2000 {
        // Compute new price
        n = next(n);
        let new_price = (n % 10) as i32;

        // Update differences and set new price
        a = b;
        b = c;
        c = d;
        d = new_price - price;
        price = new_price;

        // Update the hashmap of total prices with this price
        // (only if the sequence of differences is new)
        let seq = (a, b, c, d);
        if k >= 3 && !seen.contains(&seq) {
            match total_price.get_mut(&seq) {
                Some(x) => *x += price,
                None => {
                    total_price.insert(seq, price);
                }
            };
            seen.insert(seq);
        }
    }
}
